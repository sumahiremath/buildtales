---
layout: default
title: "GitHub Copilot: Zero to Hero — Build Your First Ruby Project with AI Pair Programming"
date: 2025-08-26
categories: [ai-tools, systems]
section: "Leveraging AI Tools"
excerpt: "Learn GitHub Copilot by building a Ruby CLI project from scratch. A hands-on, end-to-end guide from installation to tests, persistence, and documentation."
banner_image: "/assets/banners/resized/20250826copilot-ruby-blog.jpg"
banner_image_series: "/assets/banners/resized/20250826copilot-ruby-series.jpg"
banner_color: "#157878"

# SEO and Canonical Tags
canonical_url: "https://buildtales.dev/fintech/systems/2025/08/26/github-copilot-ruby-zero-hero.html"
author:
  name: "Suma Manjunath"
  twitter: "@buildtales"
  
# Open Graph / Social Media
og:
  title: "GitHub Copilot: Zero to Hero — Build Your First Ruby Project with AI Pair Programming"
  description: "Learn GitHub Copilot by building a Ruby CLI project from scratch. A hands-on, end-to-end guide from installation to tests, persistence, and documentation."
  type: "article"
  
# Twitter Card
twitter:
  card: "summary"
  title: "GitHub Copilot: Zero to Hero — Build Your First Ruby Project with AI Pair Programming"
  description: "Learn GitHub Copilot by building a Ruby CLI project from scratch. A hands-on, end-to-end guide from installation to tests, persistence, and documentation."

# Syndication and Original Content Declaration
robots: "index, follow"
syndication:
  original: true
  republish_allowed: true
  canonical_source: "BuildTales.dev"

# Series information
series:
  name: "Leveraging AI Tools for Engineering Teams"
  index_url: "/series/systems"
  part: 3
---

# GitHub Copilot: Zero to Hero — Build Your First Ruby Project with AI Pair Programming
*Learn Copilot by building a complete app from scratch — no fluff, just code.*

<div class="personal-branding">
  <img src="/assets/images/ghibli-avatar.jpg" alt="Suma Manjunath" class="ghibli-avatar">
  <div class="author-info">
    <div class="author-name">Author: Suma Manjunath</div>
    <div class="publish-date">Published on: {{ page.date | date: "%B %d, %Y" }}</div>
    {% if page.last_modified_at %}
    <div class="update-date">Updated on: {{ page.last_modified_at | date: "%B %d, %Y" }}</div>
    {% endif %}
  </div>
</div>

<img src="/assets/banners/resized/20250826copilot-ruby-blog.jpg" alt="GitHub Copilot: Zero to Hero" class="article-header-image">

---

## What You'll Learn
By the end of this tutorial you'll have:  
- A working **Ruby CLI Todo app**  
- Automated tests with **Minitest**  
- JSON persistence  
- A **README** generated by Copilot  
- Experience using Copilot for **generation, refactoring, and error handling**

💡 **Estimated time:** ~45–60 minutes

---

## GitHub Copilot: Zero to Hero — The Complete, Practical Guide

*A hands-on playbook for developers and teams to get real work done with Copilot.*

### Table of Contents

1. [What Copilot Actually Does (and When to Use It)](#what-copilot-actually-does-and-when-to-use-it)
2. [Quick Start (VS Code / JetBrains / Neovim)](#quick-start-vs-code--jetbrains--neovim)
3. [Daily Workflow: Autocomplete + Chat + PRs](#daily-workflow-autocomplete--chat--prs)
4. [Prompting That Works (Copy‑Paste Recipes)](#prompting-that-works-copy‑paste-recipes)
5. [Debugging, Tests, and Refactors with Copilot](#debugging-tests-and-refactors-with-copilot)
6. [Docs, Terminals, and Repos: Asking Copilot About Your Code](#docs-terminals-and-repos-asking-copilot-about-your-code)
7. [Architecture & "Big Changes" (Safely)](#architecture--big-changes-safely)
8. [Security, Privacy, and Responsible Use](#security-privacy-and-responsible-use)
9. [Team Rollout: Rules, Reviews, and Metrics](#team-rollout-rules-reviews-and-metrics)
10. [Troubleshooting & Common Pitfalls](#troubleshooting--common-pitfalls)
11. [Cheat Sheets](#cheat-sheets)
12. [Appendix: Editor Settings, Snippets, and Templates](#appendix-editor-settings-snippets-and-templates)

---

### What Copilot Actually Does (and When to Use It)

**Copilot ≠ magic.** Think of it as three superpowers:

1. **Autocomplete (ghost text)** – fastest for scaffolding and repeating patterns.
2. **Chat** – ask questions about your codebase, get explanations, generate diffs.
3. **Reviews/PR help** – summarize changes, suggest tests, explain diffs.

**Use it when**:

* You know *what* you want but not exact syntax.
* You're repeating a pattern (CRUD, DTOs, API handlers, tests).
* You're exploring a library's "shape" (e.g., fs/promises, FastAPI, Prisma).

**Don't use it when**:

* You don't understand your own acceptance criteria yet.
* You're doing sensitive crypto, auth, or compliance-critical logic (write it yourself first, then ask Copilot to refactor/tests).

---

### Quick Start (VS Code / JetBrains / Neovim)

#### VS Code (fastest)

1. Install **GitHub Copilot** and **GitHub Copilot Chat** extensions.
2. Sign in to GitHub → authorize.
3. In **Settings**:

   * Enable inline suggestions: `editor.inlineSuggest.enabled = true`
   * Language toggles: `github.copilot.enable` (per language)
4. Open any file → type a function comment → accept suggestion with **Tab**.

**Sanity test**

```ts
// Create a function that returns the top N numbers from an array using a heap.
```

You should get a draft inlined. If not, type a few lines to "prime" it.

#### JetBrains (WebStorm/IntelliJ)

* Install **GitHub Copilot** plugin from Marketplace.
* File → Settings → Tools → GitHub Copilot → Sign in → enable inline.

#### Neovim

* Use `github/copilot.vim` or `zbirenbaum/copilot.lua`.
* Map `<Tab>`/`<C-]>` to accept suggestions.
* Ensure Node.js installed for the extension.

---

### Daily Workflow: Autocomplete + Chat + PRs

**Morning 10-minute warmup**

* Open your main task ticket.
* In Copilot Chat: *"Summarize the responsibilities of `UserService` and show me entry points where I can add email verification."*
* Accept a skeleton plan and ask for a **task checklist**.

**Build loop**

1. **Comment-first**: write 1–3 lines describing the function.
2. Accept ghost text; run tests.
3. In Chat: *"Generate tests for the new function; include sad paths."*
4. Refactor via Chat: *"Simplify with early returns, add input validation."*

**PR time**

* In Chat: *"Summarize my changes since last commit."*
* Ask: *"Propose a PR title & body with risks and test notes."*
* Push → open PR → paste summary and risks.

---

### Prompting That Works (Copy‑Paste Recipes)


#### Pattern 1 — Comment‑Driven Generation

```ts
// Build a robust pagination helper that supports page, perPage, totalCount,
// returns { data, pagination: { page, perPage, totalPages, hasNext, hasPrev } }.
// No external libraries.
```

#### Pattern 2 — Spec → Implementation

```plaintext
You are a senior TypeScript engineer. Implement a lightweight event bus:
- subscribe(event, handler) -> unsubscribe() 
- publish(event, payload)
- multiple handlers per event
- ensure no memory leaks
- include minimal JSDoc
Return a single file implementation plus 3 usage examples.
```

#### Pattern 3 — "Constrain the solution"

```plaintext
Refactor this to pure functions only (no classes, no mutation, no I/O):
[PASTE FUNCTION]
Keep the surface API the same. Explain tradeoffs in 3 bullets.
```

#### Pattern 4 — "Small scope, fast results"

```plaintext
@src/utils/formatCurrency.ts
Add support for custom locales and currencies; default to USD en-US.
Add tests for EUR de-DE and JPY ja-JP.
```

#### Pattern 5 — "Test-first"

```plaintext
Given this function, write table-driven tests covering edge cases
(negative numbers, zero, big numbers, floats, NaN):

[PASTE FUNCTION]
```

#### Pattern 6 — "Explain & document"

```plaintext
Explain what this function does in plain English, then produce a docstring:

[PASTE FUNCTION]
```

> 💡 **Tip:** If a response goes off-track, narrow scope: *"Only change the `parse()` function. Leave everything else untouched."*

---

### Debugging, Tests, and Refactors with Copilot

#### Debugging (targeted)

```plaintext
The following throws occasionally in production (null pointer):
- Show two likely root causes, then one minimal diff to fix
- Add a guard that logs safe diagnostic info (no secrets)

[PASTE FUNCTION]
```

#### Generate/refactor tests

```plaintext
Write Jest tests for `getInvoiceTotals`:
- 100% branch coverage
- Boundary cases: empty items, very large values, rounding rules
- Name tests clearly and minimize fixtures
```

#### Performance pass

```plaintext
Profile this function and propose O() improvements, then return a diff only.

[PASTE FUNCTION]
```

#### Safe refactor (multi-file)

```plaintext
I want to split `AuthService` into `AuthService` + `TokenService` (new file).
- Move sign/verify JWT to TokenService
- Keep public API of AuthService stable
- Show a patch touching only these files: AuthService.ts, TokenService.ts, index.ts
```

---

### Docs, Terminals, and Repos: Asking Copilot About Your Code

In VS Code Chat you can mention:

* `@workspace` – ask about the whole repo ("Where does order cancellation start?").
* `@file`/`@editor` – discuss the open file.
* `@terminal` – ask about recent command errors.

Examples:

```plaintext
@workspace Map the data flow for checkout from controller to DB writes.
Return a mermaid sequence diagram.
```

```plaintext
@terminal The last `docker compose up` failed. Read the logs and propose a fix.
```

```plaintext
@workspace Locate all places where we parse user-provided JSON.
List risky spots and add try/catch with metrics (no secrets).
```

---

### Architecture & "Big Changes" (Safely)

**Recipe: Plan → Prove → Patch**

1. **Plan (no changes yet)**

```plaintext
We're migrating from JS to TS in /api only.
- Propose an incremental plan in 4 steps
- Estimate risk and test impact
- Identify 3 files to convert first
```

2. **Prove (tiny PR)**

```plaintext
Convert only `src/api/utils/date.js` to TypeScript with strict types.
Add minimal tests to prove correctness. Return a patch.
```

3. **Patch (controlled batch)**

```plaintext
Convert these 5 files to TS with the same patterns used previously:
[list paths]
Keep exports stable. Diff only.
```

> 💡 **Guardrails:** Use branches, keep PRs < 300 lines, run tests between each step.

---

### Security, Privacy, and Responsible Use

* **Secrets**: Never paste tokens/keys into prompts. Mask/redact.
* **Compliance-sensitive code**: Write it yourself first; ask Copilot to review or add tests.
* **Telemetry & data**: Review org policies and repository-level settings before enabling across sensitive codebases.
* **Generated code**: Treat as junior-dev output until reviewed & tested.

---

### Team Rollout: Rules, Reviews, and Metrics

#### Shared "Copilot Rules" (put in your team handbook/README)

* **Comment-first** coding; keep comments succinct and specific.
* **No blind-commit**: run tests; require one human review for any AI-heavy change.
* **Security**: no secrets in prompts; redaction required.
* **Style**: use the repo's linter/formatter as the single source of truth.
* **Prompt discipline**: prefer file-scoped prompts over repo-wide asks.

#### Review checklist (lightweight)

* [ ] Does the code follow our style/lint rules?
* [ ] Are edge cases/tests included?
* [ ] Is error handling explicit and observable?
* [ ] Is the solution maintainable (naming, structure)?
* [ ] Any security/PII concerns?

#### Measuring ROI (starter metrics)

* **Lead time** for routine features (baseline vs with Copilot).
* **PR iteration count** (does AI code need fewer/more cycles?).
* **Test coverage** for AI-authored areas.
* **Onboarding time** for new devs (time to first merged PR).

---

### Troubleshooting & Common Pitfalls

| Problem              | Why it happens              | Fix                                                  |
| -------------------- | --------------------------- | ---------------------------------------------------- |
| Suggestions are off  | Context is vague            | Add a comment or select a smaller code region        |
| Chat is generic      | Repo isn't "in view"        | Use `@workspace` and reference concrete files        |
| Reverts your changes | Over-broad prompt           | Say "touch only this function/file; no other edits." |
| Hallucinated APIs    | Model guessed library usage | Paste the actual API signature or link to docs       |
| Huge diffs           | Asked for repo-wide change  | Batch into 3–5 file patches with tests between       |

---

### Cheat Sheets

#### High-Impact Prompts (copy/paste)

```plaintext
Explain this function like I'm new to the codebase. Then show 2 safe refactors.
[PASTE]
```

```plaintext
Generate happy + sad path tests for the new endpoint using supertest/pytest.
```

```plaintext
Show a minimal diff to add input validation and return 400 with reasons.
```

```plaintext
Find duplicated logic across these files and extract a reusable helper.
[list files]
```

```plaintext
Create a migration plan from axios to fetch with a small pilot patch.
```

#### Language Starters

**Node/Express route**

```js
// POST /api/orders - validates input, writes to DB, returns 201 or detailed 400
```

**Python/FastAPI service**

```py
# Write a service that calculates invoice totals with discounts and taxes:
# - support rounding rules
# - raise ValueError on invalid items
# - include pydantic models and pytest
```

**React component**

```tsx
// Accessible modal component with focus trap, ESC to close, ARIA roles.
# Provide tests with React Testing Library.
```

---

### Appendix: Editor Settings, Snippets, and Templates

#### VS Code Settings (drop in `settings.json`)

```json
{
  "editor.inlineSuggest.enabled": true,
  "github.copilot.enable": {
    "*": true,
    "plaintext": false,
    "markdown": true
  },
  "editor.suggest.preview": true,
  "editor.acceptSuggestionOnEnter": "on",
  "editor.quickSuggestions": {
    "strings": true
  }
}
```

#### Git Commit Template (prompts better PR help)

```
# Why
# What (bullet points)
# Risks / Rollback
# Tests (coverage, cases)
```

#### PR Description Template (for Copilot to summarize well)

```
## Summary
<what changed in 1-2 lines>

## Details
- bullet
- bullet

## Tests
- unit/integration/e2e
- edge cases

## Risks & Rollback
- known risks
- rollback plan
```

---

### Your 7‑Day "Zero → Hero" Plan

**Day 1:** Install, enable inline, comment‑first function.
**Day 2:** CRUD endpoint + tests from chat prompts.
**Day 3:** Refactor two functions; ask Copilot to explain diffs.
**Day 4:** Add input validation + error mapping, generate tests.
**Day 5:** Create a small feature branch; ask for PR summary.
**Day 6:** Ask `@workspace` to map a flow; add metrics to 2 risky spots.
**Day 7:** Run a mini-migration (3 files), document lessons learned.

> 💡 **Final tip:** Keep scopes tight. Copilot shines when your ask is small, concrete, and surrounded by the right context (file selection, comments, constraints). Stack those small wins and you'll be "hero mode" in a week.

---  

---

## Prerequisites
- Ruby installed (`ruby -v` to check)  
- Basic comfort with the command line  
- VS Code with **GitHub Copilot** + **Copilot Chat** extensions installed  

---

## Step 1: Setup (~5 minutes)
```bash
mkdir todo_ruby && cd todo_ruby
code .
```

💡 **Tip:** Copilot works with Ruby out of the box — no config needed.

---

## Step 2: Generate the Core Class (~5 minutes)

Create `todo.rb` and type a comment:

```ruby
# A simple command-line Todo app in Ruby
```

Copilot suggests:

```ruby
class TodoApp
  def initialize
    @tasks = []
  end

  def add_task(task)
    @tasks << { text: task, done: false }
  end

  def list_tasks
    @tasks.each_with_index do |task, i|
      status = task[:done] ? "[x]" : "[ ]"
      puts "#{i+1}. #{status} #{task[:text]}"
    end
  end

  def mark_done(index)
    @tasks[index][:done] = true if @tasks[index]
  end
end
```

✔️ Skeleton complete.

---

## Step 2.5: Ask Copilot About Idioms (~3 minutes)

Try:

```
Review this class and suggest more idiomatic Ruby improvements
```

Copilot might suggest:

* Using `Struct` for tasks
* Replacing manual index checks with `fetch`
* Using `each.with_index(1)` instead of `each_with_index`

💡 **Tip:** This is where Copilot shines — nudging you toward best practices.

---

## Step 3: Build a CLI Runner (~10 minutes)

Ask Copilot Chat:

```
Make this TodoApp usable from the command line with commands: add, list, done, quit
```

It generates:

```ruby
class TodoApp
  # ... same as above ...
end

# CLI runner
app = TodoApp.new

loop do
  puts "Commands: add <task>, list, done <index>, quit"
  input = gets.strip.split(" ", 2)
  command, arg = input[0], input[1]

  case command
  when "add"
    app.add_task(arg)
  when "list"
    app.list_tasks
  when "done"
    if arg && arg.to_i > 0
      app.mark_done(arg.to_i - 1)
    else
      puts "Invalid index"
    end
  when "quit"
    break
  else
    puts "Unknown command"
  end
end
```

✔️ You now have a working CLI app with basic error handling.

💡 **Tip:** Always ask Copilot to add guards like *"handle invalid input gracefully"*.

---

## Step 4: Add Tests (~10 minutes)

Create `test_todo.rb`:

```ruby
require "minitest/autorun"
require_relative "todo"

class TodoAppTest < Minitest::Test
  def setup
    @app = TodoApp.new
  end

  def test_add_task
    @app.add_task("Buy milk")
    assert_equal 1, @app.instance_variable_get(:@tasks).length
  end
end
```

Ask Copilot:

```
Add tests for list_tasks and mark_done, including invalid index
```

Copilot expands the test suite automatically:

```ruby
def test_list_tasks
  @app.add_task("Buy eggs")
  assert_output("1. [ ] Buy eggs\n") { @app.list_tasks }
end

def test_mark_done
  @app.add_task("Do laundry")
  @app.mark_done(0)
  assert @app.instance_variable_get(:@tasks)[0][:done]
end

def test_mark_done_with_invalid_index
  @app.add_task("Cook dinner")
  assert_silent { @app.mark_done(99) }
end
```

✔️ You now have **happy + sad path tests**.

---

## Step 5: Add Persistence (~10 minutes)

Prompt Copilot:

```
Update TodoApp to save/load tasks from tasks.json
```

Generated:

```ruby
require "json"

class TodoApp
  def initialize(file = "tasks.json")
    @file = file
    @tasks = File.exist?(@file) ? JSON.parse(File.read(@file), symbolize_names: true) : []
  end

  def save
    File.write(@file, JSON.pretty_generate(@tasks))
  end

  def add_task(task)
    @tasks << { text: task, done: false }
    save
  end

  def mark_done(index)
    @tasks[index][:done] = true if @tasks[index]
    save
  end
end
```

✔️ Now your app persists across runs.

---

## Step 6: Refactor with Copilot (~5 minutes)

Ask:

```
Refactor TodoApp to use a Task class instead of hash, and keep the same public API
```

Copilot suggests:

```ruby
Task = Struct.new(:text, :done, keyword_init: true)

# @tasks is now an array of Task objects
```

💡 **Tip:** Use Copilot not just to generate, but to **modernize and refactor**.

---

## Step 7: Generate Documentation (~2 minutes)

In Copilot Chat:

```
Generate a README.md for this project with usage instructions
```

Example output:

```markdown
# Ruby Todo CLI App

## Usage
```bash
ruby todo.rb
```

### Commands
- `add <task>` – Add a new task
- `list` – List all tasks
- `done <index>` – Mark a task as done
- `quit` – Exit the app
```

✔️ Docs in seconds.

---

## Step 8: Run the Full App (~5 minutes)

```bash
ruby todo.rb
```

Demo session:

```
> add Learn Copilot
> add Write blog post
> list
1. [ ] Learn Copilot
2. [ ] Write blog post
> done 1
> list
1. [x] Learn Copilot
2. [ ] Write blog post
> quit
```

---

## 🚨 What *Not* to Do with Copilot

![Copilot donts](/assets/banners/resized/copilotdonts-blog.jpg)

Copilot is powerful, but it's not infallible. Here are **pitfalls to avoid**:

* **❌ Blindly trusting output**
  Always review Copilot's suggestions like you would a junior developer's PR.

* **❌ Asking vague prompts**
  "Fix my app" is too broad. Be specific: *"Handle invalid index in mark_done method."*

* **❌ Refactoring the whole repo at once**
  Big diffs are hard to validate. Work in **small, test-backed chunks**.

* **❌ Using it for sensitive logic**
  Write security, crypto, or compliance code yourself — use Copilot for tests and docs.

* **❌ Forgetting error handling**
  Copilot defaults to happy paths. Always add *"handle invalid input gracefully."*

💡 **Rule of thumb:** Copilot works best when you keep prompts **tight, test-driven, and iterative**.

---

## Wrap-Up

In under an hour, with minimal typing, you built:

* ✅ A Ruby CLI Todo app
* ✅ Automated tests (happy + sad paths)
* ✅ JSON persistence
* ✅ A refactored Task model
* ✅ A README

All guided by GitHub Copilot.

> 💡 **Hero takeaway:** Copilot isn't just autocomplete — it's a full AI coding partner that takes you from a blank folder to a polished, tested project.

---

## Next Steps

**Extend your app:**
- Add task priorities and due dates
- Implement task deletion and editing
- Add categories and filtering
- Build a web interface with Sinatra

**Level up with Copilot:**
- Try pair programming on a larger project
- Use Copilot for code reviews and documentation
- Experiment with different prompt strategies
- Integrate with your existing development workflow

**Resources:**
- [GitHub Copilot Documentation](https://docs.github.com/en/copilot)
- [Ruby Style Guide](https://rubystyle.guide/)
- [Minitest Best Practices](https://github.com/minitest/minitest)

---
